_runtimePath_ "runtime"
_runtimeStart_ &h7FFF
_arraysStart_ &h7FFF
_codeRomType_ ROMvX0

'size of your most complex expression, (temporary variables required)*2, defaults to 8
_tempVarSize_ 16

'free string work area, (better not use any of the string runtime!)
free STRINGWORKAREA

'defines the amount of contiguous RAM needed for blit stripes, (in this case 15*6 + 1), also min address and search direction
_blitStripeChunks_ 15, &h3BA0, &h7FFF, descending

def x, y, button, sp, dx, dy, ang, score, hiscore, objframe, spikex, spikey, coinx, coiny, asp, ht

const lutsize = 64

const maxspd = 845

const startspeed = 384
const boostspeed = 768

const angsp = 1024
const grav = 10

const falldiv = 1
const fallbase = 256
const spdivup = 32 'speed reduction divider while going up
const spdivdw = 32 'speed increse divider while going down

const coinbonus = 128
const spikedamage = 32

const sw = 16
const sh = 14

const objw = 8
const objh = 8

const bt_left = &hfd
const bt_right = &hfe

const bt_start = &h7f


dim sinlut(lutsize - 1) = { 
	0, 5, 10, 14, 19, 24, 29, 34,
    39, 43, 48, 54, 58, 63, 68, 73,
    77, 82, 87, 91, 95, 100, 105, 109,
    113, 118, 122, 125, 130, 134, 139, 143,
    148, 152, 156, 160, 164, 168, 173, 177,
    181, 185, 188, 192, 196, 199, 203, 207,
    211, 213, 217, 221, 224, 226, 230, 233,
    236, 239, 242, 244, 247, 250, 252, 256,
}

const glider_up = 0
load blit, ../img/gliderup.tga, glider_up + 0, NoFlip

const glider_nt = 1
load blit, ../img/gliderside.tga, glider_nt + 0, NoFlip

const glider_dw = 2
load blit, ../img/gliderdown.tga, glider_dw + 0, NoFlip

const glider_lup = 3
load blit, ../img/gliderupl.tga, glider_lup + 0, NoFlip

const glider_lnt = 4
load blit, ../img/glidersidel.tga, glider_lnt + 0, NoFlip

const glider_ldw = 5
load blit, ../img/gliderdownl.tga, glider_ldw + 0, NoFlip

const logo = 6
load blit, ../img/logo.tga, logo + 0, NoFlip

const spr_coin0 = 7
load blit, ../img/coin0.tga, spr_coin0 + 0, NoFlip

const spr_coin1 = 8
load blit, ../img/coin1.tga, spr_coin1 + 0, NoFlip

const spr_coin2 = 9
load blit, ../img/coin2.tga, spr_coin2 + 0, NoFlip

const spr_coin3 = 10
load blit, ../img/coin3.tga, spr_coin3 + 0, NoFlip

const spr_spike0 = 11
load blit, ../img/spike0.tga, spr_spike0 + 0, NoFlip

const spr_spike1 = 12
load blit, ../img/spike1.tga, spr_spike1 + 0, NoFlip

const spr_spike2 = 13
load blit, ../img/spike2.tga, spr_spike2 + 0, NoFlip

const spr_anti = 15
load blit, ../img/antiobj.tga, spr_anti + 0, NoFlip


call initSystem

reset:
    call resetLevel
    
start:
    call startLevel
    
init:
    call initVars

loop:
	call waitScanline
	
    button = get("BUTTON_STATE") 
	objframe = objframe + 64
	
	if button == bt_right then ang = ang + angsp	'right
	if button == bt_left  then ang = ang - angsp	'left
	
	
	
	
	
	call calcdxdy
	
	if sp.hi AND 128 
		sp = 0
	endif
	
	if sp > maxspd
		sp = maxspd
	endif
	
	
	'at 100,2	
	'PRINT score
	'at 0,8	
	'PRINT sp.hi
	'at 0,16	
	'PRINT dy
	
	
	'x = x + dx
	spikex = spikex - dx
	coinx = coinx - dx
	
	y = y + dy
	
	if x.hi+16 > coinx.hi and x.hi < coinx.hi + 8	
		if y.hi+14 > coiny.hi and y.hi < coiny.hi + 8
			score = score + 1
			sp = sp + coinbonus
			call recoin
		endif
	endif
	
	if ht > 0
		ht = ht - 1
	endif
	
	if x.hi+16 > spikex.hi and x.hi < spikex.hi + 8	
		if y.hi+14 > spikey.hi and y.hi < spikey.hi + 8
			
			if sp > boostspeed 
				call respike
				score = score + 1
			elseif ht == 0
				sp = 256
				ht = 240
			endif
		endif
	endif
	
	if coinx < 0 
		call recoin
	endif
	
	if spikex < 0 
		call respike
	endif
	
	if x.hi > 142 then x.hi = 1
	if x.hi <= 0 then x.hi = 142
	
	if y <= 0 then y.hi = 0
	if y.hi > 105 then y.hi = 105 : dy = -dy
	
	
	blit NoFlip, spr_coin0 + (objframe.hi % 4), coinx.hi, coiny.hi
	blit NoFlip, spr_spike0 + (objframe.hi % 3), spikex.hi, spikey.hi
	
	call aniplayer

goto loop

proc initSystem
    mode 2
    set FGBG_COLOUR, &h3F00
endproc

proc resetLevel
    cls
	
endproc

proc startLevel
   cls
   score = 0

endproc

proc initVars
    x.hi = 71
	y.hi = 30
	
	spikex.hi = 120 
	spikey.hi = 40
	
	coinx.hi = 120
	coiny.hi = 75
	
	objframe = 0
	
	score = 0
	
	sp = startspeed
	
	dx = 0
	dy = 0
	
	ht = 0
	
	ang = 0
	
	blit NoFlip, logo, 38, 16
	
	call printscore
	
	at 32,90
	PRINT "PRESS A TO START"
endproc
	
proc waitScanline
    repeat
    until (get("VIDEO_Y") AND 1)
endproc

proc aniplayer
	local gspr
	gspr = 0

	if dy > 128
		gspr = glider_dw
	elseif dy < -128
		gspr = glider_up
	else
		gspr = glider_nt
	endif
	
	if (dx.hi AND 128)
		gspr = gspr + glider_lup
	endif
	
	blit NoFlip, gspr, 70, y.hi
endproc


proc calcdxdy 
	'need to improve the speed by reducing the max determination time
	local angindex, angpoint
	
	angindex = ang.hi%64
	angpoint = (ang.hi AND 192)
	
	
	'angle between 192 and 255 meaning 270 and 360 deg
	if (angpoint == 192)
		
		dx = sp.hi * sinlut(angindex)
		dy = sp.hi * -sinlut(lutsize - 1 - angindex)
		ang = ang + (sinlut(lutsize - 1 - angindex) / sp.hi) + fallbase
		sp = sp - (sinlut(lutsize - 1 - angindex) / spdivup)
		
		return
	endif
	
	'angle between 128 and 191 meaning 180 and 270 deg
	if (angpoint == 128)
		
		dx = sp.hi * -sinlut(lutsize - 1 - angindex)
		dy = sp.hi * -sinlut(angindex)
		ang = ang - (sinlut(angindex) / sp.hi) - fallbase
		sp = sp - (sinlut(angindex) / spdivup)
		
		return
	endif
	
	'angle between 64 and 127 meaning 90 and 180 deg
	if (angpoint == 64)
		
		dx = sp.hi * -sinlut(angindex)
		dy = sp.hi * sinlut(lutsize - 1 - angindex)
		ang = ang - (sinlut(lutsize - 1 - angindex) / sp.hi) - fallbase
		sp = sp + (sinlut(lutsize - 1 - angindex) / spdivdw)
		
		return
	endif
	
	'angle between 0 and 63 meaning 0 and 90 deg
	dx = sp.hi * sinlut(lutsize - 1 - angindex) 
	dy = sp.hi * sinlut(angindex)
	ang = ang + (sinlut(angindex) / sp.hi) + fallbase
	sp = sp + (sinlut(angindex) / spdivdw)

endproc

proc recoin:
	coinx.hi = 127
	coiny.hi = 10 + rnd(100)
	
	call printscore
endproc

proc respike:
	spikex.hi = 127
	spikey.hi = 10 + rnd(100)
	
	call printscore
endproc

proc printscore
	at 36,4
	PRINT score
endproc